<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7690"/>

<div>
<span><div><div><div>20201119 第11课</div><hr/><div><br/></div><div><span style="font-weight: bold;">1.Java8 Lambda*</span></div></div><div><br/></div><div>Lambda表达式 lambda expression</div><div>是一个匿名函数</div><div>Java中，函数不是第一等公民，需要封装到接口里。</div><div><br/></div><div>方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。</div><div>注意，方法签名不包括方法的返回类型和访问修饰符。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.无参数，有返回值</div><div>() -&gt; 5;</div><div>2.1个参数，有返回值</div><div>x -&gt; x*2;</div><div>3.2个参数，有返回值</div><div>(x,y) -&gt; x - y;</div><div>4.2个参数，有返回值，显式写类型</div><div>(int x, int y) -&gt; x + y;</div><div>5.1个参数，无返回值</div><div>(String str) -&gt; System.out.println(str);</div><div>System.out::println;</div></div><div><br/></div><div><a href="https://app.yinxiang.com/shard/s52/nl/11173257/796024ec-fe31-4725-ae1c-94c3b7f9ca0d">Lambda 表达式有何用处？</a></div><div><br/></div><div>@FunctionalInterface</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface <b>Function</b>&lt;T, R&gt; {</div><div>    R apply(T t);</div><div>}</div><div>// 有参数，无返回值</div><div>public interface <b>Consumer</b>&lt;T&gt; {</div><div>    void accept(T t);</div><div>}</div><div>// 无参数，有返回值</div><div>public interface <b>Supplier</b>&lt;T&gt; {</div><div>    T get();</div><div>}</div><div>// 断言</div><div>public interface <b>Predicate</b>&lt;T&gt; {</div><div>    boolean test(T t);</div><div>}</div><div>// Binary</div><div>public interface <b>BiFunction</b>&lt;T, U, R&gt; {</div><div>    R apply(T t, U u);</div><div>}</div></div><div><br/></div><div>方法引用 ::</div><div><br/></div><div>Java8实战</div><div><br/></div><div><span style="font-weight: bold;">2.Java8 Stream*</span></div><div><br/></div><div>通过反射可以拿到泛型</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class GenericDemo {</div><div>    public static void main(String[] args) {</div><div>        Demo demo = new Demo();</div><div>        Class&lt;? extends Demo&gt; clazz = demo.getClass();</div><div>        // 获得该类的父类</div><div>        // class com.transformers.advanced.week06.class11.GenericDemo$Person</div><div>        System.out.println(clazz.getSuperclass());</div><div>        // Type是 Java 编程语言中所有类型的公共高级接口。</div><div>        // 它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。</div><div>        Type type = clazz.getGenericSuperclass();</div><div>        // 带有泛型的父类</div><div>        // com.transformers.advanced.week06.class11.GenericDemo$Person&lt;com.transformers.advanced.week06.class11.GenericDemo&gt;</div><div>        System.out.println(type);</div><div>        // ParameterizedType参数化类型，即泛型</div><div>        ParameterizedType parameterizedType = (ParameterizedType) type;</div><div>        // 获取参数化类型的数组，泛型可能有多个</div><div>        Type actualTypeArgument = parameterizedType.getActualTypeArguments()[0];</div><div>        // class com.transformers.advanced.week06.class11.GenericDemo</div><div>        Class actualTypeArgumentClass = (Class) actualTypeArgument;</div><div>        System.out.println(actualTypeArgumentClass);</div><div>        System.out.println(actualTypeArgument);</div><div>    }</div><div>    static class Person&lt;T&gt; {</div><div>    }</div><div>    static class Demo extends Person&lt;GenericDemo&gt; {</div><div>    }</div><div>}</div></div><div><br/></div><div>泛型的约束，来约束泛型的类型</div><div>&lt;T extends Serializable&gt;</div><div>约定多个接口</div><div>&lt;T extends Number &amp; Serializable &amp; Comparable&gt;</div><div><br/></div><div>Stream流</div><div>流是一个来自数据源的元素队列，支持聚合操作</div><div>元素*，特定类型的对象，形成一个队列</div><div>数据源*，流的来源，可以是集合，数组，IO channel，产生器generator等</div><div>聚合操作，类似SQL语句</div><div>与Collection不同，Stream操作2个基础特征：</div><ol><li><div>pipelining：中间操作都会返回流对象本身，多个操作可以可以串联成一个管道，如同流式风格fluent style，这样可以延迟执行laziness和短路short-circuiting。</div></li><li><div>内部迭代，通过访问者模式visitor实现</div></li></ol><div>创建流的方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int[] arr;</div><div>Arrays.stream(arr)</div><div><br/></div><div>Stream.of()</div></div><div><br/></div><div>Stream操作</div><div>中间操作：</div><ol><li><div>选择与过滤</div></li><ol><li><div><span style="font-weight: bold;">filter</span>(Predicate p)，从流中排除某些元素</div></li><li><div>distinct()，根据hashCode和equals去重</div></li><li><div>limit(long maxSize)，截断流，使其元素不超过给定数量</div></li><li><div>skip(long n)跳过元素，返回一个扔了n个元素的流；若流中元素不足n个，则返回一个空流</div></li></ol><li><div>映射</div></li><ol><li><div><span style="font-weight: bold;">map</span>(Function f)，将元素转换成其他形式或提取信息；接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</div></li><li><div>mapToDouble(ToDoubleFunction f)，接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</div></li><li><div>mapToInt(ToIntFunction f)，接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</div></li><li><div>mapToLong(ToLongFunction f)，接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</div></li><li><div>flatMap(Function f)，接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</div></li></ol><li><div>排序</div></li><ol><li><div> sorted()产生一个新流，其中按自然顺序排序</div></li><li><div>sorted(Comparator comp)产生一个新流，其中按比较器顺序排序</div></li></ol></ol><div>终止操作</div><ol><li><div>查找与匹配</div></li><ol><li><div>allMatch，检查是否匹配所有元素</div></li><li><div>anyMatch，检查是否至少匹配一个元素</div></li><li><div>noneMatch，检查是否没有匹配的元素</div></li><li><div>findFirst，返回第一个元素</div></li><li><div>findAny，返回当前流中任意元素</div></li><li><div>count，返回流中元素的总个数</div></li><li><div>max，返回流中最大值</div></li><li><div>min，返回流中最小值</div></li></ol><li><div>规约reduce，需要初始值（类似Map-Reduce）</div></li><li><div>收集collect</div></li><ol><li><div>toList，把流中元素收集到List</div></li><li><div>toSet，把流中元素收集到Set</div></li><li><div>toCollection，把流中元素收集到创建的集合</div></li><li><div>count，计算流中元素个数</div></li><li><div>summaryStatistics，统计最大最小平均值</div></li></ol><li><div>迭代forEach</div></li></ol><div>并行操作不会有线程安全问题，因为只有闭包问题，不会影响外部变量；而且只有部分操作才能并行，如map，像reduce不能并行。</div><div><br/></div><div>流操作中，为了避免NPE导致流断，都使用Optional封装了。</div><div>等价于C#中，基本类型关键字后面加问号</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int? i = null;</div></div><div>toMap时，重复的key需要处理，否则报错</div><div><br/></div><div>lambda表达式debug</div><ol><li><div>IDEA中可以在一行上debug</div></li><li><div>把之前的单行代码加上大括号{}，再debug</div></li></ol><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>lambda核心是作用域</div><div>x是类属性，不是方法变量</div><div>public class ForEachDemo {</div><div>    private int x = 1;</div><div>    private void test() {</div><div>        List&lt;Integer&gt; list = Arrays.asList(1, 3);</div><div>        int y = 3;</div><div>        list.forEach(x -&gt; {</div><div>            this.x = 2;</div><div>            // Variable used in lambda expression should be final or effectively final</div><div>            // y = 5;</div><div>        });</div><div>    }</div><div>    public static void main(String[] args) {</div><div>        ForEachDemo demo = new ForEachDemo();</div><div>        // 1</div><div>        System.out.println(demo.x);</div><div>        demo.test();</div><div>        // 2</div><div>        System.out.println(demo.x);</div><div>    }</div><div>}</div></div><div><br/></div><div>闭包</div><div>1. 闭包就相当于执行环境自动将方法执行上下文封装为了一个对象，然后因为被其他地方异步引用，所以方法执行完这个context对象却没有被回收。</div><div>2. java的labmda和闭包没关系，虽然lambda中可以引用方法内的局部变量，但这些局部变量都必须是final的，所以相当于调用lambda时有了一些蕴含的传参。</div><div>3. 闭包就相当于是一次动态执行上下文封装成的变量Map，由执行环境来负责处理，既然是共享上下文，那么可以由多个回调函数或者内部函数在外部访问，相当于一种封装技术。</div><div><br/></div><div>3.Lombok</div><div><br/></div><div>Lombok是基于JSR269实现的一个Java类库</div><div>会利用注解自动生成set、get方法及有参无参构造方法</div><div>还能生成logger、toString、hashCode、builder等java特色函数或符合设计模式的方法</div><div>让Java更简洁更美观</div><div>基于字节码增强，编译期处理（生成class文件时起作用）</div><div>可以配置开发工具</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Setter</div><div>@Getter</div><div>@Data</div><div>@XXXConstructor</div><div>@Builder</div><div>@ToString</div><div>@Slf4j</div></div><div><br/></div><div>4.Guava</div><div><br/></div><div>基于开源的Java库</div><div>包含谷歌正在使用的很多核心库</div><div>为了方便编码，减少编码错误</div><div>提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，IO和验证的实用方法</div><div>好处：</div><ol><li><div>标准化 - 由谷歌托管</div></li><li><div>高效 - 可靠，快速和有效的扩展Java标准库</div></li><li><div>优化 - 经过了高度的优化</div></li></ol><div>JDK8中一些新特性源于Guava</div><div>集合</div><ol><li><div>不可变集合</div></li><li><div>新集合类型：multisets，multimaps，tables，bidirectionalmaps等</div></li><li><div>集合工具类</div></li><li><div>扩展工具类，创建Collection的装饰器</div></li></ol><div><br/></div><div>缓存【Caches】</div><ol><li><div>本地缓存实现，支持多种缓存过期策略</div></li></ol><div>zk客户端使用了缓存</div><div><br/></div><div>并发【Concurrency】</div><div>ListenableFuture，完成后触发回调的Future</div><div><br/></div><div>字符串处理【Strings】</div><div>分割，连接，填充等</div><div><br/></div><div>事件总线【EventBus】</div><div>发布订阅模式的组件通信，进程内模块间解耦</div><div>接口在A项目</div><div>B项目实现A项目中接口，实现方式：</div><ol><li><div>Java自带的ServiceLoader，SPI，服务加载器</div></li><li><div>callback机制，listener机制，观察者模式</div></li><li><div>EventBus，真正的解耦</div></li></ol><div><br/></div><div>SPI关键，在META-INF/services文件夹下创建以接口全限定名为文件名的文件，里面写上实现这个接口的类的全限定名</div><div><img src="class11_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 看到ss源码内map的使用</div><div>Map&lt;Integer, Collection&lt;String&gt;&gt; map = Maps.newConcurrentMap();</div><div>for (int i = 0; i &lt; 3; i++) {</div><div>    Collection&lt;String&gt; strList = map.computeIfAbsent(i, unused -&gt; new LinkedHashSet());</div><div>    strList.add(i + &quot;&quot;);</div><div>}</div><div>for (int i = 0; i &lt; 6; i++) {</div><div>    Collection&lt;String&gt; strList = map.computeIfAbsent(i, unused -&gt; new LinkedHashSet());</div><div>    strList.add(i + &quot;a&quot;);</div><div>}</div><div>for (int i = 0; i &lt; 6; i++) {</div><div>    Collection&lt;String&gt; strList = map.computeIfAbsent(i, unused -&gt; new LinkedHashSet());</div><div>    strList.add(i + &quot;a&quot;);</div><div>}</div><div>System.out.println(map);</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// </span>{0=[0, 0a], 1=[1, 1a], 2=[2, 2a], 3=[3a], 4=[4a], 5=[5a]}</div></div><div><br/></div><div>EventBus代码</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@NoArgsConstructor(access = AccessLevel.PRIVATE)</div><div>public final class EventBusUtil {</div><div>    public static final <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>EventBus EVENT_BUS = new EventBus(&quot;study&quot;);</b></span></div><div>    public static EventBus getEventBus() {</div><div>        return EVENT_BUS;</div><div>    }</div><div>}</div><div><br/></div><div>@Data</div><div>@ToString</div><div>public class EventDTO {</div><div>    private int id;</div><div>    private List&lt;String&gt; list;</div><div>}</div><div><br/></div><div>public class Demo {</div><div>    <b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">@Subscribe</b></div><div>    public void handle(EventDTO eventDTO) {</div><div>        System.out.println(this + &quot; -&gt; Demo.handle -&gt; &quot; + eventDTO);</div><div>    }</div><div>}</div><div><br/></div><div>public class Main {</div><div>    public static void main(String[] args) {</div><div>        EventDTO eventDTO = new EventDTO();</div><div>        eventDTO.setId(95);</div><div>        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div>        list.add(&quot;1&quot;);</div><div>        list.add(&quot;2&quot;);</div><div>        eventDTO.setList(list);</div><div><br/></div><div><br/></div><div>        EventBusUtil.getEventBus().<b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">register</b>(new Demo());</div><div>        EventBusUtil.getEventBus().<b>register</b>(new Demo());</div><div><br/></div><div><br/></div><div>        EventBusUtil.getEventBus().<b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">post</b>(eventDTO);</div><div>    }</div><div>}</div></div><div><br/></div><div>反射【reflection】</div><div><br/></div><div><span style="font-weight: bold;">5.设计原则*</span></div><div><br/></div><div>代码是给人看的</div><div>JVM只解析字节码</div><div><br/></div><div>S.O.L.I.D</div><div>面向对象设计和编程（OOD&amp;OOP）中几个重要的编码原则（Programming Principle）<span style="font-size: unset; color: unset; font-family: unset;">首字母缩写</span><span style="font-size: unset; color: unset; font-family: unset;">SRP（Single Responsibility Principle）</span><span style="font-size: unset; color: unset; font-family: unset;">单一职责原则</span></div><div>OCP（Open Closed Principle）开放封闭原则</div><div>    对扩展开放，对修改关闭</div><div>LSP（Liskov Substitution Principle）里氏替换原则</div><div>ISP（Interface Segregation Principle）接口分离原则</div><div>DIP（Dependency Inversion Principle）依赖倒置原则</div><div><br/></div><div>最小知识原则KISS</div><div><span style="font-weight: bold;">高内聚低耦合</span></div><div><br/></div><div>A依赖于B和C，A依赖于B，在B中对C做一个代理</div><div>A与B相互依赖，共同提升一个类O，或是AB继承O，或是O作为AB的属性组合进去，组合模式</div><div><br/></div><div>编码规范、结合checkstyle工具</div><div>    降低沟通成本，避免常见错误</div><div>常见的编码规范：</div><ol><li><div><a href="https://google.github.io/styleguide/javaguide.html">google</a></div></li><li><div><a href="https://github.com/alibaba/p3c">Alibaba</a></div></li><li><div><a href="https://vipshop.github.io/vjtools/#/standard/">VIP（唯品会）</a></div></li></ol><div><br/></div><div>架构设计规范</div><div>技术调研规范</div><div>数据库规范</div><div><br/></div><div><span style="font-weight: bold;">6.设计模式*</span></div><div><br/></div><div>GoF23设计模式</div><div>创建型（通用）创建新对象</div><ol><li><div>Factory Method（工厂方法）</div></li><li><div>Abstract Factory（抽象工厂）</div></li><li><div>Builder（建造者）</div></li><li><div>Prototype（原型）</div></li><li><div>Singleton（单例）</div></li></ol><div>结构性（通用）组合对象</div><ol><li><div>Adapter（适配器）</div></li><li><div>Bridge（桥接）</div></li><li><div>Composite（组合）</div></li><li><div>Decorator（装饰）调用数据库5行3列，转换4行6列，修改修饰</div></li><li><div>Facade（外观）</div></li><li><div>Flyweight（享元）</div></li><li><div>Proxy代理，功能原封不动的，造了个壳子</div></li></ol><div>行为型（针对具体的某种场景）</div><ol><li><div>Interpreter（解释器）</div></li><li><div>Template Method（模板方法）</div></li><li><div>Chain of Responsibility（责任链）管道+filter</div></li><li><div>Command（命令）</div></li><li><div>Iterator（迭代器）</div></li><li><div>Mediator（中介者）</div></li><li><div>Memento（备忘录）</div></li><li><div>Observer（观察者）</div></li><li><div>State（状态）</div></li><li><div>Strategy（策略）</div></li><li><div>Visitor（访问者）</div></li></ol><div><br/></div><div>模式的3个层次</div><ol><li><div>解决方案层面 - 架构模式</div></li><li><div>组件层面 - 框架模式</div></li><li><div>代码层面 - GoF设计模式</div></li></ol><div>其他模式：</div><ol><li><div>集成模式</div></li><li><div>事务模式</div></li><li><div>IO模式/Context模式</div></li><li><div>状态机FSM</div></li><li><div>规则引擎RE</div></li><li><div>workflow工作流</div></li></ol><div>反模式：</div><ol><li><div>死用模式</div></li></ol><div><br/></div><div><span style="font-weight: bold;">7.单元测试*</span></div><div><br/></div><div>单元测试覆盖率</div><div>jacoco</div><div>emma</div><div>coberuta</div><div>sonar</div><div>checkstyle</div><div>findbugs</div><div><br/></div><div>mvn emma:emma</div><div>mvn coberuta:coberuta</div><div><br/></div><div>github上</div><div>travis</div><div>coveralls</div><div>codecov</div><div><br/></div><div>IDEA右键项目</div><div>run 'all test' with coverage</div><div><br/></div><div>一个方法是一个单元</div><div><br/></div><div>手工回归测试</div><div>自动化端到端测试</div><div>集成测试</div><div>单元测试</div><div><br/></div><div>UI：录制脚本，回放脚本</div><div>服务</div><div>单元：最小粒度单元-方法，是符合预期的</div><div><br/></div><div>单元测试理论基础：发现缺陷越早越提前，修复成本越低</div><div>    需求文档</div><div>    设计</div><div>    开发，写代码时</div><div>    测试阶段</div><div>    上线</div><div><br/></div><div>Junit TestCase，TestSuit，Runner</div><div>SpringTest</div><div>Mock技术</div><div>    <span style="font-weight: bold;">Mockito</span></div><div>    easyMock</div><div>认为外部依赖都是ready的</div><div><br/></div><div>如何做单元测试</div><ol><li><div>每个方法是一个case，断言充分，提示明确（如集合个数，每个内容）</div></li><ol><li><div>注意断言库与Junit参数可能是颠倒的！</div></li></ol><li><div>单侧要覆盖所有的corner case</div></li><li><div>充分使用mock（一切皆可mock）</div></li><li><div>如果发现不好测试，则说明业务代码设计存在问题，可以反向优化代码</div></li><ol><li><div>测试驱动开发</div></li></ol><li><div>批量测试用例使用参数化单元测试（参数化测试）</div></li><li><div>注意测试是单线程执行</div></li><li><div>合理使用before，after，setup准备环境</div></li><li><div>合理使用通用测试基类</div></li><li><div>配合checkstyle，coverage等工具</div></li><li><div>制定单元测试覆盖率基线</div></li><ol><li><div>最核心子项目90%</div></li><li><div>业务80-85%</div></li><li><div>重要性不高的60-75%</div></li><li><div>分级处理</div></li></ol></ol><div>单元测试的常见陷阱与经验</div><ol><li><div>尽量不要访问外部数据库等外部资源</div></li><ol><li><div>实在区分不开，可以使用内存数据库等</div></li><li><div>依赖了数据库，需要把所有数据都回滚到测试前状态</div></li></ol><li><div>如果必须使用数据库考虑使用嵌入式DB+事务自动回滚</div></li><li><div>防止静态变量污染导致测试无效</div></li><ol><li><div>不要用非final静态变量</div></li><li><div>全局静态变量before先给预定值，然后在after还原</div></li></ol><li><div>小心测试方法的顺序导致的不同环境测试失败</div></li><ol><li><div>跟操作系统相关</div></li><li><div>单元测试类与类之间，类的方法之间不要有依赖关系</div></li></ol><li><div>单元测试总时间特别长的问题</div></li><ol><li><div>自动化代替人工检查错误</div></li><li><div>corner case特别多</div></li><li><div>dubbo20分钟</div></li><li><div>ss半个小时</div></li></ol></ol><div><img src="class11_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Test</div><div>@BeforeEach</div><div>@AfterEach</div><div>@BeforeAll</div><div>@AfterAll</div><div>@Disabled</div><div>@EnabledOnOs({ OS.LINUX, OS.MAC })</div><div>@DisabledOnJre(JRE.JAVA_8)</div><div>@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</div><div>@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</div><div><br/></div><div>@ParameterizedTest</div><div>@ValueSource(ints = { 0, 1, 5, 100 })</div><div>void testAbs(int x) {</div><div>    assertEquals(x, Math.abs(x));</div><div>}</div><div><br/></div><div>@ParameterizedTest</div><div>@MethodSource</div><div>void testCapitalize(String input, String result) {</div><div>    assertEquals(result, StringUtils.capitalize(input));</div><div>}</div><div>static List&lt;Arguments&gt; testCapitalize() {</div><div>    return Lists.newArrayList(</div><div>            Arguments.arguments(&quot;abc&quot;, &quot;Abc&quot;),</div><div>            Arguments.arguments(&quot;APPLE&quot;, &quot;Apple&quot;),</div><div>            Arguments.arguments(&quot;GooD&quot;, &quot;Good&quot;)</div><div>    );</div><div>}</div><div><br/></div><div>@CsvSource({&quot;abc,Abc&quot;, &quot;APPLE,Apple&quot;, &quot;GooD,Good&quot;})</div><div>@CsvFileSource(resources = {&quot;/test-capitalize.csv&quot;})</div><div><br/></div><div>assertEquals</div><div>assertTrue()</div><div>assertFalse()</div><div>assertNotNull()</div><div>assertArrayEquals()</div><div>assertThrows(Class&lt;T&gt; expectedType, Executable executable)</div></div><div><br/></div><div><span style="font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;">看书与看代码一样，需要抓住重点，有重点的看！</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;">组建2个兴趣小组，每周交流，努力成为其中一员！</span></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 