<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7309"/>

<div>
<span><div><div><div><div>20201112 第9课</div><hr/><div><br/></div><div>沉默的大多数要说话</div></div><div><br/></div><div>秦老师提的5点要求：</div><ol><li><div>空杯心态，学习一定是反人性的</div></li><li><div>有意见提意见</div></li><li><div>作业要完成最低标准（作业可以后面完成，但不要形成滚雪球，消费贷效应）</div></li><li><div>认识清楚：课程定位，梳理脉络，建立知识体系</div></li><li><div>成为技术高手，听老师的成功经验</div></li></ol><div><br/></div><hr/><div><br/></div><div>1. Spring技术发展</div><div>2002年10月 Rod Johnson，《Expert One-on-One J2EE Developmeng without EJB》</div><div>2003年2月 Rod Juergen Yann开发Spring项目。</div><div>2004年1.0版本发布</div><div>2007年11月SpringSource</div><div>2009年8月被VMWare收购</div><div>2012年7月Rod Johnson离开了团队</div><div>2013年4月VMware和EMC通过GE投资创建了Pivotal合资企业</div><div>2013年12月，Pivotal发布Spring框架4.0</div><div>2017年9月28日，发布Spring 5.0 GA版本</div><div><br/></div><div>当年屠龙的勇士，10年后变身为恶龙。</div><div><br/></div><div>2014年发布Spring Boot</div><div>2015年发布Spring Cloud</div><div>2018年Pivotal公司在纽约上市</div><div>公司开源产品</div><ul><li><div>Spring及Spring衍生产品</div></li><li><div>Web服务器Tomcat</div></li><li><div>缓存中间件Redis</div></li><li><div>消息中间件RabbitMQ</div></li><li><div>平台即服务的Cloud Foundry、Greenplum数据引擎</div></li><li><div>GemFire（12306系统解决方案组件之一）</div></li></ul><div><br/></div><div>里程碑版本</div><ul><li><div>2.5.6</div></li><li><div>3.3.1</div></li><li><div>4.x</div></li></ul><div>不建议用最新版本，最新版本有坑。</div><div>追最新技术没有太大意义，除非是基于某个领域。</div><div>建议使用jdk11，不建议使用jdk15</div><div><br/></div><div><span style="font-weight: bold;">2. Spring框架设计*</span></div><div>组件：业务组件（订单组件）、技术组件（日历组件）</div><div>部件</div><div>框架：不直接解决业务问题，用了之后可以更加专注的解决技术问题</div><div>模式</div><div><br/></div><div>Spring framework六大模块</div><ol><li><div>Core：Bean/Context/AOP</div></li><li><div>Testing：Mock/TestContext</div></li><li><div>DataAccess：Tx/JDBC/ORM</div></li><li><div>Spring MVC/WebFlux：web</div></li><li><div>Integration：remoting/JMS/WS（EIP）</div></li><li><div>Languages：Kotlin/Groovy（多语言编程）</div></li></ol><div><br/></div><div>引入Spring意味着引入了一种研发协作模式。</div><div>横切竖割，拆分为小组件，便于分工协作。</div><div><br/></div><div>POJO，Bean，Spring中也叫Bean，bean就是豆子，咖啡豆。</div><div>把Framework简写为fx。</div><div>架构和建筑是同一个词，Architecture</div><div>架构师和建筑师是同一个词，Architect</div><div><br/></div><div><span style="font-weight: bold;">3. Spring AOP详解*</span></div><div><br/></div><div>装配从编译期，挪到运行期</div><div>Spring早期核心功能：管理对象生命周期与对象装配。</div><div>实现方式：增加一个中间层代理（字节码增强）来实现所有对象的托管。</div><div><br/></div><div>IoC控制反转</div><div>DI依赖注入</div><div><br/></div><div>抽象出接口，</div><div>在编译期，不会依赖于具体的类，而是依赖于接口。</div><div><br/></div><div>好处：</div><div>打破依赖关系</div><div>修改配置文件</div><div>处理部分循环依赖问题</div><div>    属性上的循环依赖可以处理：先new出各自实例对象，属性置空，等使用时再设置即可。</div><div>装配从编译期，挪到运行期。</div><div>构造函数上的循环依赖，Spring不能处理。</div><div><br/></div><div>循环依赖场景：</div><ul><li><div>类依赖关系</div></li><li><div>jar包引用依赖关系</div></li><li><div>并发线程锁之间依赖关系</div></li><li><div>线程池多个事务之间的锁</div></li></ul><div>打破死锁：</div><ul><li><div>增加打断，打破锁，使循环依赖不能成环</div></li><ul><li><div>换一种方式</div></li><li><div>提取出一个父类，在父类中处理，子类之间尽量不要有依赖关系</div></li></ul><li><div>增加超时</div></li></ul><div><br/></div><div>通过拦截方法调用，来增强。</div><div><br/></div><div>接口类型</div><ul><li><div>默认使用JDKProxy</div></li><ul><li><div>com.sun.proxy.$Proxy</div></li></ul><li><div>CGLib</div></li><ul><li><div>proxyTargetClass=true</div></li><li><div>EnhancerBySpringCGLIB</div></li></ul></ul><div>非接口类型</div><ul><li><div>默认使用CGLib</div></li><ul><li><div>proxyTargetClass</div></li><li><div>EnhancerBySpringCGLIB</div></li></ul></ul><div><br/></div><div>2种方式</div><div>xml方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;aop1&quot; class=&quot;com.transformers.spring02.Aop1&quot;/&gt;</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">&lt;aop:aspectj-autoproxy/&gt;</span></div><div>&lt;aop:config&gt;</div><div>    &lt;!-- 切点 --&gt;</div><div>    &lt;aop:pointcut id=&quot;p1&quot; expression=&quot;execution(* com.transformers.aop.*.*(..))&quot;/&gt;</div><div>    &lt;!-- 切面 --&gt;</div><div>    &lt;aop:aspect ref=&quot;aop1&quot;&gt;</div><div>        &lt;!-- 环绕通知 --&gt;</div><div>        &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;p1&quot;/&gt;</div><div>        &lt;!-- 前置通知 --&gt;</div><div>        &lt;aop:before method=&quot;startTransaction&quot; pointcut-ref=&quot;p1&quot;/&gt;</div><div>        &lt;!-- 后置通知 --&gt;</div><div>        &lt;aop:after-returning method=&quot;commitTransaction&quot; pointcut-ref=&quot;p1&quot;/&gt;</div><div>    &lt;/aop:aspect&gt;</div><div>&lt;/aop:config&gt;</div><div><br/></div><div>public class Aop1 {</div><div>    // 前置通知</div><div>    public void startTransaction() {</div><div>        System.out.println(&quot;Aop1 before ding...&quot;);</div><div>    }</div><div>    // 后置通知</div><div>    public void commitTransaction() {</div><div>        System.out.println(&quot;Aop1 after ding...&quot;);</div><div>    }</div><div>    // 环绕通知</div><div>    public void around(ProceedingJoinPoint joinPoint) throws Throwable {</div><div>        System.out.println(&quot;Aop1.around begin ding...&quot;);</div><div>        joinPoint.proceed();</div><div>        System.out.println(&quot;Aop1.around end ding...&quot;);</div><div>    }</div><div>}</div><div><br/></div><div>使用xml方式时，前置通知和环绕通知会因为先后顺序而改变执行顺序，如果在xml文件中更换顺序后，如下2行顺序会改变</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Aop1.around begin ding...</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Aop1 before ding...</span></div><div>School.ding</div><div>Aop1.around end ding...</div><div>Aop1 after ding...</div></div><div><br/></div><div>注解方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;aop2&quot; class=&quot;com.transformers.spring02.Aop2&quot;/&gt;</div><div><br/></div><div>@Aspect</div><div>public class Aop2 {</div><div>    @Pointcut(value = &quot;execution(* com.transformers.*.Klass.*dong(..))&quot;)</div><div>    public void point() {</div><div>    }</div><div>    @Before(value = &quot;point()&quot;)</div><div>    public void before() {</div><div>        System.out.println(&quot;Aop2.before dong...&quot;);</div><div>    }</div><div>    @After(value = &quot;point()&quot;)</div><div>    public void after() {</div><div>        System.out.println(&quot;Aop2.after dong...&quot;);</div><div>    }</div><div>    @Around(value = &quot;point()&quot;)</div><div>    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {</div><div>        System.out.println(&quot;Aop2.around begin dong...&quot;);</div><div>        Object proceed = joinPoint.proceed();</div><div>        System.out.println(&quot;Aop2.around end dong...&quot;);</div><div>        return proceed;</div><div>    }</div><div>}</div><div><br/></div><div>Aop2.around begin dong...</div><div>Aop2.before dong...</div><div>Klass.dong</div><div>Aop2.around end dong...</div><div>Aop2.after dong...</div></div><div><br/></div><div>修改默认代理方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;aop:aspectj-autoproxy <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">proxy-target-class=&quot;true&quot;</span>/&gt;</div><div>// ISchool接口的对象AOP代理后的实际类型：class com.sun.proxy.$Proxy13</div><div>// ISchool接口的对象AOP代理后的实际类型：class com.transformers.spring02.School$$EnhancerBySpringCGLIB$$fa5329fd</div></div><div><br/></div><div>编码层面的侵入</div><div>其他实现AOP方式：</div><div>组合、门面模式、装饰模式</div><div><br/></div><div>反射：reflect，类似于拍CT、B超</div><div>字节码增强：emit，类似于基因操作技术</div><div>jdk1.6之后，Instrumentation，不侵入jar包，在jar包加载之前，在被ClassLoader加载之前做一个转换，javaagent，不能放在需要运行的类里面，需要单独打jar包。</div><div>AOP增强，是在目标类加载到JVM后，做一个代理，使用代理类进行操作，目标类是没有被改的。</div><div>Instrumentation增强，是在目标类加载到JVM之前，使用Instrumentation类改变目标类生成字节码文件，再加载到JVM中，后面用到的都是被改的目标类。</div><div><br/></div><div>字节码增强工具</div><ul><li><div>ASM</div></li><ul><li><div>CGLIB</div></li></ul><li><div>AspectJ</div></li><li><div>Java Proxy</div></li><li><div>Javassist</div></li><ul><li><div>Instrumentation</div></li></ul><li><div>ByteBuddy（更加友好的操作API）</div></li></ul><div>之前的技术都是需要拼字节码指令的，相当于汇编语言</div><div>ByteBuddy相对简化，进化相当于C语言</div><div><br/></div><div>编程时非常不推荐构造器装配</div><div><br/></div><div>APM，可以给不同系统使用</div><div>但是改动后有风险</div><div><br/></div><div><span style="font-weight: bold;">4. Spring Bean核心原理*</span></div><div><br/></div><div>Spring Bean生命周期</div><div>Context模式的典型应用</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">BeanFactory</span></div><div>ApplicationContext</div><div>Bean加载过程</div><ol><li><div>构造函数 new</div></li><li><div>依赖注入</div></li><li><div>BeanNameAware</div></li><li><div>BeanFactoryAware</div></li><li><div>ApplicationContextAware</div></li><li><div>BeanPostProcessor前置方法</div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">自定义init方法</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">InitializingBean</span></div></li><li><div>BeanPostProcessor后置方法</div></li><li><div>使用</div></li><li><div>DisposableBean</div></li><li><div>自定义destroy方法</div></li></ol><div>Spring作为通用框架，需要设计这么复杂</div><div>针对复杂的对象，可以使用工厂方法，封装到FactoryBean中。</div><div><br/></div><ol><li><div>实例化 Instantiation（1）</div></li><li><div>属性复制 Populate（2）</div></li><li><div>初始化 Initialization（3-9）</div></li><li><div>销毁 Destruction（11-12）</div></li></ol><div><br/></div><div>创建一个简单的Bean，debug跟踪源码</div><div>Spring默认是单例模式，建议使用单例，无状态，不会有线程安全问题。</div><div><br/></div><div>Spring管理对象生命周期以后，也就改变了编程和协作模式。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>LoadBean.java</div><div>public class LoadBean implements BeanNameAware, BeanFactoryAware, ApplicationContextAware,</div><div>        InitializingBean, DisposableBean {</div><div>    @Override</div><div>    public void setBeanName(String s) {</div><div>        System.out.println(&quot;LoadBean.setBeanName&quot;);</div><div>    }</div><div>    @Override</div><div>    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {</div><div>        System.out.println(&quot;LoadBean.setBeanFactory&quot;);</div><div>    }</div><div>    @Override</div><div>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</div><div>        System.out.println(&quot;LoadBean.setApplicationContext&quot;);</div><div>    }</div><div>    @PostConstruct</div><div>    public void customInit() {</div><div>        System.out.println(&quot;LoadBean.customInit&quot;);</div><div>    }</div><div>    @Override</div><div>    public void afterPropertiesSet() throws Exception {</div><div>        System.out.println(&quot;LoadBean.afterPropertiesSet&quot;);</div><div>    }</div><div>    @PreDestroy</div><div>    public void customDestroy() {</div><div>        System.out.println(&quot;LoadBean.customDestroy&quot;);</div><div>    }</div><div>    @Override</div><div>    public void destroy() throws Exception {</div><div>        System.out.println(&quot;LoadBean.destroy&quot;);</div><div>    }</div><div>}</div><div><br/></div><div>CustomBeanPostProcessor.java</div><div>public class CustomBeanPostProcessor implements BeanPostProcessor {</div><div>    @Override</div><div>    public Object postProcessBeforeInitialization(Object obj, String s) throws BeansException {</div><div>        System.out.println(&quot;postProcessBeforeInitialization &quot; + obj);</div><div>        return obj;</div><div>    }</div><div>    @Override</div><div>    public Object postProcessAfterInitialization(Object obj, String s) throws BeansException {</div><div>        System.out.println(&quot;postProcessAfterInitialization &quot; + obj);</div><div>        return obj;</div><div>    }</div><div>}</div><div><br/></div><div>applicationContext-loadbean.xml</div><div>&lt;context:component-scan base-package=&quot;com.transformers.bean&quot;/&gt;</div><div>&lt;bean id=&quot;loadBean&quot; class=&quot;com.transformers.bean.LoadBean&quot;/&gt;</div><div>&lt;bean class=&quot;com.transformers.bean.CustomBeanPostProcessor&quot;/&gt;</div><div><br/></div><div>ApplicationContext ctx =</div><div>        new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-loadbean.xml&quot;);</div><div>LoadBean bean = ctx.getBean(LoadBean.class);</div><div><br/></div><div>[16 16:33:31,245 DEBUG] [main] support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'loadBean'</div><div>[16 16:33:31,245 DEBUG] [main] support.DefaultListableBeanFactory - Creating instance of bean 'loadBean'</div><div>[16 16:33:31,248 DEBUG] [main] annotation.CommonAnnotationBeanPostProcessor - Found init method on class [com.transformers.bean.LoadBean]: public void com.transformers.bean.LoadBean.customInit()</div><div>[16 16:33:31,248 DEBUG] [main] annotation.CommonAnnotationBeanPostProcessor - Found destroy method on class [com.transformers.bean.LoadBean]: public void com.transformers.bean.LoadBean.customDestroy()</div><div>[16 16:33:31,248 DEBUG] [main] annotation.CommonAnnotationBeanPostProcessor - Registered init method on class [com.transformers.bean.LoadBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1b44421</div><div>[16 16:33:31,249 DEBUG] [main] annotation.CommonAnnotationBeanPostProcessor - Registered destroy method on class [com.transformers.bean.LoadBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@99781b49</div><div>[16 16:33:31,251 DEBUG] [main] support.DefaultListableBeanFactory - Eagerly caching bean 'loadBean' to allow for resolving potential circular references</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LoadBean.setBeanName</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LoadBean.setBeanFactory</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LoadBean.setApplicationContext</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">postProcessBeforeInitialization com.transformers.bean.LoadBean@401e7803</span></div><div>[16 16:33:31,254 DEBUG] [main] annotation.CommonAnnotationBeanPostProcessor - Invoking init method on bean 'loadBean': public void com.transformers.bean.LoadBean.customInit()</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LoadBean.customInit</span></div><div>[16 16:33:31,254 DEBUG] [main] support.DefaultListableBeanFactory - Invoking afterPropertiesSet() on bean with name 'loadBean'</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LoadBean.afterPropertiesSet</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">postProcessAfterInitialization com.transformers.bean.LoadBean@401e7803</span></div><div>[16 16:33:31,254 DEBUG] [main] support.DefaultListableBeanFactory - Finished creating instance of bean 'loadBean'</div><div>[16 16:33:31,255 DEBUG] [main] support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'com.transformers.bean.CustomBeanPostProcessor#0'</div><div>[16 16:33:31,255 DEBUG] [main] support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'</div><div>[16 16:33:31,269 DEBUG] [main] support.ClassPathXmlApplicationContext - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@4fcd19b3]</div><div>[16 16:33:31,269 DEBUG] [main] support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'lifecycleProcessor'</div><div>[16 16:33:31,272 DEBUG] [main] env.PropertySourcesPropertyResolver - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source</div><div>[16 16:33:31,273 DEBUG] [main] support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'loadBean'</div></div><div><br/></div><div><span style="font-weight: bold;">5. Spring XML配置原理*</span></div><div>xml描述格式有2种：xsd和dtd</div><div>dtd是基于文档的</div><div>xsd是基于xml的，更加规范</div><div><br/></div><div>shardingsphere例子</div><div>在xml中引用xsd文件，在spring.schemas文件中定义，指向classpath下的xsd文件。</div><div>在spring.handlers中定义转换器，将xml文件转换为Java对象。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\test\resources\META-INF\spring\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">application-context.xml</span></div><div><br/></div><div>http://shardingsphere.apache.org/schema/shardingsphere/datasource/datasource.xsd</div><div><br/></div><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\main\resources\META-INF\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">spring.schemas</span></div><div><br/></div><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\main\resources\META-INF\namespace\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">datasource.xsd</span></div><div><br/></div><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\main\resources\META-INF\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">spring.handlers</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\main\java\org\apache\shardingsphere\spring\namespace\handler\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">DataSourceNamespaceHandler.java</span></div><div>D:\workspace\idea2019.3.5\Java_advanced\shardingsphere\shardingsphere-jdbc\shardingsphere-jdbc-spring\shardingsphere-jdbc-core-spring\shardingsphere-jdbc-core-spring-namespace\src\main\java\org\apache\shardingsphere\spring\namespace\parser\<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">DataSourceBeanDefinitionParser.java</span></div></div><ul><li><div>自定义标签</div></li><li><div>schema location</div></li><li><div>spring.schemas 检查XML配置是否正确</div></li><li><div>spring.handler 从DOM节点parse对象</div></li><li><div>Bean</div></li></ul><div><br/></div><div>定义一个规则：</div><div>    所有xml配置的结构与Bean里的属性、层次结构都一致</div><div>自动化XML配置工具</div><div>Apache <span style="font-size: unset; color: unset; font-family: unset;">XmlBeans -&gt; Spring-xbean</span></div><div><span style="font-size: unset;"><br/></span></div><div>2个原理：</div><ol><li><div>根据Bean的字段结构，自动生成xsd</div></li><li><div>根据Bean的字段结构，配置xml文件</div></li></ol><div>xbean有自己实现的handler，无需手写。</div><div><br/></div><div><div>Spring Bean配置演化</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 165px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="width: 165px; padding: 8px; border: 1px solid;"><div>XML</div><div>@Autowired</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>1.0/2.0</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>XML配置/注解注入</div></td></tr><tr><td style="width: 165px; padding: 8px; border: 1px solid;"><div>@Service</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>2.5</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>半自动注解配置</div></td></tr><tr><td style="width: 165px; padding: 8px; border: 1px solid;"><div>@Bean</div><div>@Configuration</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>3.0</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>Java Config配置</div></td></tr><tr><td style="width: 165px; padding: 8px; border: 1px solid;"><div>@ComponentScan</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>3.1</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>包扫描</div></td></tr><tr><td style="width: 165px; padding: 8px; border: 1px solid;"><div>@Condition</div><div>@AutoConfigureXX</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><br/></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>全自动注解配置</div></td></tr></tbody></table><div>组件化/插件化的实现方式</div></div><div><br/></div><div><br/></div><div>6. Spring Messaging等技术</div><div><br/></div><div>RPC方式，如果一个节点慢，所有依赖于这个节点的节点都会受影响。</div><div>MQ方式</div><ol><li><div>同步转异步，监听回调等通知</div></li><li><div>依赖关系变简单了，都依赖MQ，没有那么复杂了</div></li></ol><div><br/></div><div>JMS集成，J2EE规范，类似于JDBC</div><div><br/></div><div>点对点模式</div><div>发布订阅模式</div><div><br/></div><div>《分布式消息》模块系统化讲解MQ</div><div><br/></div><div>启动ActiveMQ</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>activemq.bat start</div></div><div><br/></div><div>aspectj</div><div>java规范默认开源</div><div><br/></div><div>性能分两部分</div><div>创建类，只有一次</div><div>生成的字节码，生成出来后，再调用方法，性能没有什么差别</div><div><br/></div><div>创建连接池时有差异</div><div><br/></div><div>IO操作是性能差异的成百上千倍</div><div><br/></div></div><div>处理Web Service经典的2个包：</div><ul><li><div>CXF</div></li><li><div>Axis2</div></li></ul><div>Spring WebService</div><div>相当于RPC</div><div><span style="font-size: unset; color: unset; font-family: unset;">wsdl文件</span></div><div><br/></div></div><div>kafka、RocketMQ原生不支持jms，但有第三方适配</div><div><br/></div><div>知识图谱，自己整理</div></span>
</div></body></html> 