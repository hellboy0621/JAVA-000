<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6518"/>

<div>
<span><div><div><div><div>20201105 第7课</div><hr/><div><br/></div><div>线程相关基础知识回顾 到00:20:00</div></div><hr/><div><br/></div><div><span style="font-weight: bold;">线程池原理与应用*</span></div><div><br/></div><div>池化技术</div><div>线程池从功能上来看，就是一个任务执行器。</div><div><br/></div><div>Executor</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface Executor {</div><div>    <b>void execute</b>(Runnable command);</div><div>}</div></div><div><br/></div><div>ExecutorService</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface ExecutorService extends Executor</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>void shutdown(); // 关闭线程池，停止接收新任务，原任务继续执行</div><div>List&lt;Runnable&gt; shutdownNow();// 关闭线程池，停止接收新任务，原任务停止执行</div><div>boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</div><div>boolean isShutdown();</div><div>boolean isTerminated();</div><div>&lt;T&gt; <b>Future&lt;T&gt;</b> <b>submit</b>(Callable&lt;T&gt; task);</div><div>&lt;T&gt; <b>Future&lt;T&gt;</b> <b>submit</b>(Runnable task, T result);</div><div><b>Future&lt;?&gt;</b> <b>submit</b>(Runnable task);</div></div><div><div>awaitTermination需要结合shutdown或shutdownNow方法使用。</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 175px;"></col><col style="width: 199px;"></col></colgroup><tbody><tr><td style="width: 175px; padding: 8px; border: 1px solid;"><div>execute</div></td><td style="width: 199px; padding: 8px; border: 1px solid;"><div>submit</div></td></tr><tr><td style="width: 175px; padding: 8px; border: 1px solid;"><div>无返回值</div></td><td style="width: 199px; padding: 8px; border: 1px solid;"><div>有返回值，用Future封装</div></td></tr><tr><td style="width: 175px; padding: 8px; border: 1px solid;"><div>执行任务无法捕获异常</div></td><td style="width: 199px; padding: 8px; border: 1px solid;"><div>可以在主线程中捕获</div></td></tr></tbody></table><div><span style="font-size: unset; color: unset; font-family: unset;">AbstractExecutorService</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public abstract class AbstractExecutorService implements ExecutorService</div></div><div><br/></div><div>ThreadPoolExecutor</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public ThreadPoolExecutor(int corePoolSize,</div><div>                          int maximumPoolSize,</div><div>                          long keepAliveTime,</div><div>                          TimeUnit unit,</div><div>                          <b>BlockingQueue</b>&lt;Runnable&gt; workQueue,</div><div>                          ThreadFactory threadFactory,</div><div>                          RejectedExecutionHandler handler)</div><div><br/></div><div>public void <b>execute</b>(Runnable command) {</div><div>    if (command == null)</div><div>        throw new NullPointerException();</div><div>    /*</div><div>     * Proceed in 3 steps:</div><div>     *</div><div>     * 1. If fewer than corePoolSize threads are running, try to</div><div>     * start a new thread with the given command as its first</div><div>     * task.  The call to addWorker atomically checks runState and</div><div>     * workerCount, and so prevents false alarms that would add</div><div>     * threads when it shouldn't, by returning false.</div><div>     *</div><div>     * 2. If a task can be successfully queued, then we still need</div><div>     * to double-check whether we should have added a thread</div><div>     * (because existing ones died since last checking) or that</div><div>     * the pool shut down since entry into this method. So we</div><div>     * recheck state and if necessary roll back the enqueuing if</div><div>     * stopped, or start a new thread if there are none.</div><div>     *</div><div>     * 3. If we cannot queue task, then we try to add a new</div><div>     * thread.  If it fails, we know we are shut down or saturated</div><div>     * and so reject the task.</div><div>     */</div><div>    int c = ctl.get();</div><div>    if (workerCountOf(c) &lt; corePoolSize) {</div><div>        if (addWorker(command, true))</div><div>            return;</div><div>        c = ctl.get();</div><div>    }</div><div>    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {</div><div>        int recheck = ctl.get();</div><div>        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div>            reject(command);</div><div>        else if (workerCountOf(recheck) == 0)</div><div>            addWorker(null, false);</div><div>    }</div><div>    else if (!addWorker(command, false))</div><div>        reject(command);</div><div>}</div></div><div><img src="class07_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>之所以这样设计，把两种线程使用模式/场景都兼容了</div><div>    CPU密集型：先创建核心线程，满了后，加入队列，因为在此时如果再增加过多的线程只会增加CPU负担（频繁的上下文切换等），所以先加队列比先加线程要好。</div><div>    IO密集型：先创建核心线程，满了后，加入队列，此时前面的任务还没有执行结束，加入队列作为缓冲；如果队列满了，前面还没有执行完，再增加线程处理新任务。</div><div><br/></div><div>BlockingQueue</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>LinkedBlockingQueue</div><div>ArrayBlockingQueue</div><div>PriorityBlockingQueue</div><div>SynchronizedQueue</div></div><div><img src="class07_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>拒绝策略</div><div>CallerRunsPolicy最常用，此时主线程执行任务，后面的任务就阻塞了，设计很巧妙。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface RejectedExecutionHandler {</div><div>    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</div><div>}</div><div><br/></div><div>/**</div><div>* A handler for rejected tasks that throws a</div><div>* {@code RejectedExecutionException}.</div><div>*/</div><div>public static class <b>AbortPolicy</b> implements <b>RejectedExecutionHandler</b></div><div><br/></div><div>/**</div><div>* A handler for rejected tasks that silently discards the</div><div>* rejected task.</div><div>*/</div><div>public static class <b>DiscardPolicy</b> implements RejectedExecutionHandler</div><div><br/></div><div>/**</div><div>* A handler for rejected tasks that discards the oldest unhandled</div><div>* request and then retries {@code execute}, unless the executor</div><div>* is shut down, in which case the task is discarded.</div><div>*/</div><div>public static class <b>DiscardOldestPolicy</b> implements RejectedExecutionHandler</div><div><br/></div><div>/**</div><div>* A handler for rejected tasks that runs the rejected task</div><div>* directly in the calling thread of the {@code execute} method,</div><div>* unless the executor has been shut down, in which case the task</div><div>* is discarded.</div><div>*/</div><div>public static class <b>CallerRunsPolicy</b> implements RejectedExecutionHandler</div></div><div><br/></div><div>ThreadFactory</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface ThreadFactory {</div><div>    Thread newThread(Runnable r);</div><div>}</div><div><br/></div><div>// 自定义线程工厂类</div><div>public class CustomThreadFactory implements ThreadFactory {</div><div>    private AtomicInteger serial = new AtomicInteger(0);</div><div><br/></div><div>    @Override</div><div>    public Thread newThread(@NotNull Runnable r) {</div><div>        Thread thread = new Thread(r);</div><div>        // 根据需要，设置守护线程</div><div>        thread.setDaemon(true);</div><div>        thread.setName(&quot;CustomThread-&quot; + serial.getAndIncrement());</div><div>        return thread;</div><div>    }</div><div>}</div><div><br/></div><div>// Executors类中默认线程工厂</div><div>/**</div><div>* The default thread factory</div><div>*/</div><div>static class DefaultThreadFactory implements ThreadFactory {</div><div>    private static final AtomicInteger poolNumber = new AtomicInteger(1);</div><div>    private final ThreadGroup group;</div><div>    private final AtomicInteger threadNumber = new AtomicInteger(1);</div><div>    private final String namePrefix;</div><div><br/></div><div>    DefaultThreadFactory() {</div><div>        SecurityManager s = System.getSecurityManager();</div><div>        group = (s != null) ? s.getThreadGroup() :</div><div>                              Thread.currentThread().getThreadGroup();</div><div>        namePrefix = &quot;pool-&quot; +</div><div>                      poolNumber.getAndIncrement() +</div><div>                     &quot;-thread-&quot;;</div><div>    }</div><div><br/></div><div>    public Thread newThread(Runnable r) {</div><div>        Thread t = new Thread(group, r,</div><div>                              namePrefix + threadNumber.getAndIncrement(),</div><div>                              0);</div><div>        if (t.isDaemon())</div><div>            t.setDaemon(false);</div><div>        if (t.getPriority() != Thread.NORM_PRIORITY)</div><div>            t.setPriority(Thread.NORM_PRIORITY);</div><div>        return t;</div><div>    }</div><div>}</div></div><div><br/></div><div>Executors</div><div>创建线程池方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 单线程，相当于串行GC</div><div>// 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</div><div>public static ExecutorService <b>newSingleThreadExecutor</b>() {</div><div>    return new FinalizableDelegatedExecutorService</div><div>        (new ThreadPoolExecutor(1, 1,</div><div>                                0L, TimeUnit.MILLISECONDS,</div><div>                                new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div>}</div><div>// 如果某个线程因为执行异常而结束，那么线程池会补充一个新的线程</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">// 没有控制队列大小</span></div><div>public static ExecutorService <b>newFixedThreadPool</b>(int nThreads) {</div><div>    return new ThreadPoolExecutor(nThreads, nThreads,</div><div>                                  0L, TimeUnit.MILLISECONDS,</div><div>                                  <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">new LinkedBlockingQueue&lt;Runnable&gt;()</span>);</div><div>}</div><div>// 如果线程池大小超过了处理任务所需的线程，那么就会回收部分空闲线程；</div><div>// 如果任务数增加，又可以智能的添加新线程来处理任务</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">// 没有控制最大线程数</span></div><div>public static ExecutorService <b>newCachedThreadPool</b>() {</div><div>    return new ThreadPoolExecutor(0, <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Integer.MAX_VALUE</span>,</div><div>                                  60L, TimeUnit.SECONDS,</div><div>                                  new SynchronousQueue&lt;Runnable&gt;());</div><div>}</div><div>// 定时及周期性执行任务</div><div>public static ScheduledExecutorService <b>newScheduledThreadPool</b>(int corePoolSize) {</div><div>    return new ScheduledThreadPoolExecutor(corePoolSize);</div><div>}</div><div>public ScheduledThreadPoolExecutor(int corePoolSize) {</div><div>    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</div><div>          new DelayedWorkQueue());</div><div>}</div></div><div>使用schedule后调用shutdown，会执行完任务后停止线程池。</div><div>*如果使用scheduleAtFixedRate后调用shutdown，会立即停止线程池。</div><div><br/></div><div>创建固定线程池经验</div><div>    假设核心数为N</div><div>    CPU密集型应用，N或N+1</div><div>    IO密集型应用，2N或2(N+1)</div><div><br/></div><hr/><div><br/></div><div>Callable</div><div>Future</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface Future&lt;V&gt; {</div><div>    boolean cancel(boolean mayInterruptIfRunning);</div><div>    boolean isCancelled();</div><div>    boolean isDone();</div><div>    V get() throws InterruptedException, ExecutionException;</div><div>    V get(long timeout, TimeUnit unit)</div><div>        throws InterruptedException, ExecutionException, TimeoutException;</div><div>}</div></div><div><br/></div><div>有意义的问题分类</div><ol><li><div>确定问题</div></li><li><div><span style="font-size: unset; color: unset; font-family: unset;">两难问题</span></div></li><li><div><span style="font-size: unset; color: unset; font-family: unset;">棘手问题</span></div></li></ol><div><br/></div><hr/><div><span style="font-weight: bold;">Java并发包</span></div><div><br/></div><div>rt.jar<span style="font-size: unset; color: unset; font-family: unset;"> runtime</span></div><div>java.awt.*</div><div>    封装的操作系统的UI，做出来的跟操作系统的风格一样，与C、C++做出来的软件一样。</div><div>    直接用操作系统的钩子指针，可以直接拿到控件。</div><div>javax.swing.*</div><div>    使用Java画出来的，与操作系统原生的控件不能对应上。</div><div><br/></div><div>java.util.* 工具包</div><div>java.util.concurrent JUC并发包</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 357px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>锁机制类</div></td><td style="width: 357px; padding: 8px; border: 1px solid;"><div>Lock/Condition/ReadWriteLock</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>原子操作类</div></td><td style="width: 357px; padding: 8px; border: 1px solid;"><div>AtomicInteger...</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>线程池相关类</div></td><td style="width: 357px; padding: 8px; border: 1px solid;"><div>Future/Callable/Executor</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>工具类</div></td><td style="width: 357px; padding: 8px; border: 1px solid;"><div>CountDownLatch/CyclicBarrier/Semaphore</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>并发集合类</div></td><td style="width: 357px; padding: 8px; border: 1px solid;"><div>CopyOnWriteArrayList/ConcurrentMap</div></td></tr></tbody></table><div><span style="font-weight: bold;">锁</span></div></div><div>synchronized可以加锁</div><div>wait/notify可以看做加锁和解锁</div><div><br/></div><div>为什么还需要显式的Lock？</div><div>    synchronized块锁不够灵活</div><div>        什么条件下去加锁</div><div>        锁多久问题</div><div>        别人已经加锁，必定会阻塞，不能实现如果被锁时就放弃获取锁</div><div>Lock</div><div>    使用方式灵活可控</div><div>在jdk1.6-1.8对synchronized关键字优化后，性能开销没有优化之前差别那么大了。</div><div><br/></div><div>Lock</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface Lock {</div><div>    void lock();</div><div>    void lockInterruptibly() throws InterruptedException;</div><div>    boolean tryLock();</div><div>    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</div><div>    void unlock();</div><div>    Condition newCondition();</div><div>}</div></div><div>可重入锁</div><div>公平锁</div><div><br/></div><div>标准用法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>lock.lock();</div><div>try {</div><div>    // 业务代码</div><div>} finally {</div><div>    lock.unlock();</div><div>}</div></div><div><br/></div><div>读写锁</div></div><div>与数据库中读写分离类似。</div><div>ReadWriteLock</div><div><br/></div><div>Condition</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface Condition {</div><div>    void await() throws InterruptedException;</div><div>    void awaitUninterruptibly();</div><div>    long awaitNanos(long nanosTimeout) throws InterruptedException;</div><div>    boolean await(long time, TimeUnit unit) throws InterruptedException;</div><div>    boolean awaitUntil(Date deadline) throws InterruptedException;</div><div>    void signal();</div><div>    void signalAll();</div><div>}</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">LockSupport</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class LockSupport {</div><div>    public static void <b>unpark(Thread thread)</b></div><div>    public static void park(Object blocker)</div><div>    public static void parkNanos(Object blocker, long nanos) </div><div>    public static void parkUntil(Object blocker, long deadline)</div><div>    public static Object getBlocker(Thread t)</div><div>    public static void <b>park</b>()</div><div>    public static void parkNanos(long nanos)</div><div>    public static void parkUntil(long deadline)</div><div>}</div></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">当前线程park后暂停了，unpark时，需要另一个线程唤醒当前线程，需要传递进去。</span></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">用锁的最佳实践</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Doug Lea 《Java并发编程：设计原则与模式》</span></div><ol><li><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">永远只在更新对象的成员变量时加锁</span></div></li><li><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">永远只在访问可变的成员变量时加锁</span></div></li><li><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">永远不在调用其他对象的方法时加锁</span></div></li></ol><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">并发原子类</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">java.util.concurrent.atomic</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">无锁技术的底层实现原理</span></div><ul><li><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Unsafe API - compare-and-swap CAS</span></div></li><li><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">CPU硬件指令支持：CAS指令</span></div></li></ul><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">AtomicInteger</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// AtomicInteger.class</div><div>private <b>volatile</b> int value;</div><div><br/></div><div>private static final <b>Unsafe</b> unsafe = Unsafe.getUnsafe();</div><div>private static final long valueOffset;</div><div><br/></div><div>static {</div><div>    try {</div><div>        valueOffset = unsafe.objectFieldOffset</div><div>            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</div><div>    } catch (Exception ex) { throw new Error(ex); }</div><div>}</div><div><br/></div><div>public final int getAndIncrement() {</div><div>    return unsafe.getAndAddInt(this, valueOffset, 1);</div><div>}</div><div><br/></div><div>// Unsafe.class</div><div>public final int getAndAddInt(Object var1, long var2, int var4) {</div><div>    int var5;</div><div>    do {</div><div>        var5 = this.getIntVolatile(var1, var2);</div><div>    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div>    return var5;</div><div>}</div><div><br/></div><div>public native int getIntVolatile(Object var1, long var2);</div><div>public final native boolean <b>compareAndSwapInt</b>(Object var1, long var2, int var4, int var5);</div></div><div><br/></div><div>锁与<span style="font-size: unset; color: unset; font-family: unset;">无锁（悲观锁与乐观锁）</span></div><div>并发不高，如果加锁，强行串行执行，没有必要。</div><div>高并发时，如果使用无锁，自旋消耗CPU，还不如加锁后串行执行效率高。</div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">LongAdder对AtomicLong的改进</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">每个线程，使用自己的属性值++，最后获取时求和。</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">分段思想</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">多路归并</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 使用Lock/Condition实现生产消费者模型</div><div>*/</div><div>public class ConditionDemo {</div><div>    public static void main(String[] args) {</div><div>        ConditionDemo cd = new ConditionDemo();</div><div>        new Thread(() -&gt; {</div><div>            for (int i = 0; i &lt; 100; i++) {</div><div>                try {</div><div>                    cd.put(i);</div><div>                } catch (InterruptedException e) {</div><div>                    e.printStackTrace();</div><div>                }</div><div>            }</div><div>        }, &quot;productor&quot;).start();</div><div>        new Thread(() -&gt; {</div><div>            for (int i = 0; i &lt; 100; i++) {</div><div>                try {</div><div>                    cd.take();</div><div>                } catch (InterruptedException e) {</div><div>                    e.printStackTrace();</div><div>                }</div><div>            }</div><div>        }, &quot;consumer&quot;).start();</div><div>    }</div><div>    private Lock lock = new ReentrantLock();</div><div>    private Condition notFull = lock.newCondition();</div><div>    private Condition notEmpty = lock.newCondition();</div><div>    private Object[] items = new Object[10];</div><div>    private int putptr, takeptr, count;</div><div>    public void put(Object obj) throws InterruptedException {</div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">lock.lock();</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        try {</span></div><div>            <b>while</b> (count == items.length) {</div><div>                <b>notFull.await();</b></div><div>            }</div><div>            items[putptr++] = obj;</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; ConditionDemo.put -&gt; &quot; + obj);</div><div>            if (putptr == items.length) {</div><div>                putptr = 0;</div><div>            }</div><div>            count++;</div><div>            <b>notEmpty.signal();</b></div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">} finally {</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">            lock.unlock();</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        }</span></div><div>    }</div><div>    public Object take() throws InterruptedException {</div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">lock.lock();</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        try {</span></div><div>            <b>while</b> (count == 0) {</div><div>                <b>notEmpty.await();</b></div><div>            }</div><div>            Object obj = items[takeptr++];</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; ConditionDemo.take -&gt; &quot; + obj);</div><div>            if (takeptr == items.length) {</div><div>                takeptr = 0;</div><div>            }</div><div>            count--;</div><div>            <b>notFull.signal();</b></div><div>            return obj;</div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">} finally {</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">            lock.unlock();</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        }</span></div><div>    }</div><div>}</div></div><div><br/></div></div></span>
</div></body></html> 