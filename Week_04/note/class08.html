<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6638"/>

<div>
<span><div><div><div><div>20201107 第8课</div><hr/><div><br/></div><div>并发工具类</div></div><div>多线程之间如何协作？</div><div><br/></div><div>简单的协作机制：</div><div>    wait/notify</div><div>    lock/condition</div><div><br/></div><div>AQS</div><div>AbstractQueuedSynchronizer </div><div>抽象队列同步器</div><div>JUC并发包中核心基础组件</div><div>CLH队列</div><div><br/></div><div>Semaphore</div><div>信号量</div><div>场景：同一时间控制并发线程数</div><div>可以通过调整acquire方法获取许可数量，达到调整权重的效果。</div><div>对于new Semaphore(0)，可以先release，再acquire，也可以正常执行。</div><div>    如果正常先acquire，就会阻塞，因为获取不到。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class SemaphoreCounter {</div><div>    public static void main(String[] args) {</div><div>        SemaphoreCounter counter = new SemaphoreCounter();</div><div>        for (int i = 0; i &lt; 100; i++) {</div><div>            new Thread(() -&gt; {</div><div>                for (int j = 0; j &lt; 10000; j++) {</div><div>                    counter.incrAndGet();</div><div>                }</div><div>            }).start();</div><div>        }</div><div>        try {</div><div>            TimeUnit.SECONDS.sleep(2);</div><div>        } catch (InterruptedException e) {</div><div>            e.printStackTrace();</div><div>        }</div><div>        System.out.println(counter.getNum());</div><div>    }</div><div>    private int num;</div><div>    private Semaphore readSemaphore = new Semaphore(100, true);</div><div>    private Semaphore writeSemaphore = new Semaphore(1);</div><div>    public int incrAndGet() {</div><div>        writeSemaphore.acquireUninterruptibly();</div><div>        try {</div><div>            return ++num;</div><div>        } finally {</div><div>            writeSemaphore.release();</div><div>        }</div><div>    }</div><div>    public int getNum() {</div><div>        readSemaphore.acquireUninterruptibly();</div><div>        try {</div><div>            return num;</div><div>        } finally {</div><div>            readSemaphore.release();</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>CountDownLatch</div><div>场景：Master线程等待Worker线程把任务执行完</div><div>减法计数器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class CountDownLatchTask implements Runnable {</div><div>    private CountDownLatch latch;</div><div>    public CountDownLatchTask(CountDownLatch latch) {</div><div>        this.latch = latch;</div><div>    }</div><div>    @Override</div><div>    public void run() {</div><div>        int millis = new Random().nextInt(1000);</div><div>        try {</div><div>            TimeUnit.MILLISECONDS.sleep(millis);</div><div>            this.latch.countDown();</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; My job is done.&quot;);</div><div>        } catch (InterruptedException e) {</div><div>            e.printStackTrace();</div><div>        }</div><div>    }</div><div>    static class Main {</div><div>        public static void main(String[] args) throws ExecutionException, InterruptedException {</div><div>            int num = 100;</div><div>            CountDownLatch cdl = new CountDownLatch(num);</div><div>            List&lt;CompletableFuture&gt; list = new ArrayList&lt;&gt;();</div><div>            for (int i = 0; i &lt; num; i++) {</div><div>                CompletableFuture&lt;Void&gt; future =</div><div>                        CompletableFuture.runAsync(new CountDownLatchTask(cdl));</div><div>                list.add(future);</div><div>            }</div><div>            cdl.await();</div><div>            System.out.println(&quot;******************** All job is done. ******************** &quot;);</div><div>            for (CompletableFuture completableFuture : list) {</div><div>                completableFuture.get();</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>CyclicBarrier</div><div>循环栅栏</div><div>加法计数器</div><div>场景：任务执行到一定阶段，等待其他任务对齐。</div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class CyclicBarrierDemo2 {</div><div><br/></div><div>    public static void main(String[] args) {</div><div>        int num = 5;</div><div>        CyclicBarrier cyclicBarrier = new CyclicBarrier(num, () -&gt; {</div><div>            // 等任务执行完成后，随便找一个之前的线程来执行这一段代码</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; 所有任务执行完毕，集合完成&quot;);</div><div>        });</div><div>        for (int i = 0; i &lt; num; i++) {</div><div>            new Thread(new WriteTask(cyclicBarrier), &quot;WriteTask-&quot; + (i + 1)).start();</div><div>        }</div><div>        try {</div><div>            TimeUnit.SECONDS.sleep(3);</div><div>        } catch (InterruptedException e) {</div><div>            e.printStackTrace();</div><div>        }</div><div><br/></div><div>        // 可以重复利用</div><div>        for (int i = 10; i &lt; 10 + num; i++) {</div><div>            new Thread(new WriteTask(cyclicBarrier), &quot;WriteTask-&quot; + (i + 1)).start();</div><div>        }</div><div>        System.out.println(&quot;Main Thread end.&quot;);</div><div>    }</div><div><br/></div><div>    static class WriteTask implements Runnable {</div><div>        private CyclicBarrier barrier;</div><div><br/></div><div>        public WriteTask(CyclicBarrier barrier) {</div><div>            this.barrier = barrier;</div><div>        }</div><div><br/></div><div>        @Override</div><div>        public void run() {</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; 开始执行写任务&quot;);</div><div>            try {</div><div>                // 使用sleep方法模拟写入方法</div><div>                TimeUnit.MILLISECONDS.sleep(500);</div><div>                System.out.println(Thread.currentThread().getName() + &quot; -&gt; 写任务执行完毕&quot;);</div><div>                barrier.await();</div><div>            } catch (InterruptedException | BrokenBarrierException e) {</div><div>                e.printStackTrace();</div><div>            }</div><div>            System.out.println(Thread.currentThread().getName() + &quot; -&gt; 所有任务执行完毕&quot;);</div><div>        }</div><div>    }</div><div>}</div></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 236px;"></col><col style="width: 224px;"></col></colgroup><tbody><tr><td style="width: 236px; padding: 8px; border: 1px solid;">CountDownLatch</td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>CyclicBarrier</div></td></tr><tr><td style="width: 236px; padding: 8px; border: 1px solid;"><div>减法计数器</div></td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>加法计数器</div></td></tr><tr><td style="width: 236px; padding: 8px; border: 1px solid;"><div>减为0时，释放所有等待线程</div></td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>加为指定数时，释放所有等待线程</div></td></tr><tr><td style="width: 236px; padding: 8px; border: 1px solid;"><div>调用countDown()方法计数减1</div><div>调用await()方法阻塞</div></td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>调用await()方法计数加1，加1后不等于指定值，线程阻塞</div></td></tr><tr><td style="width: 236px; padding: 8px; border: 1px solid;"><div>不可重复使用</div></td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>可以重复使用</div></td></tr><tr><td style="width: 236px; padding: 8px; border: 1px solid;"><div>在主线程await()方法处为聚合点</div></td><td style="width: 224px; padding: 8px; border: 1px solid;"><div>在主线程中没有聚合点，而是在构造方法barrierAction中</div></td></tr></tbody></table><div><br/></div></div><div>Future/FutureTask/CompletableFuture</div><div>future在金融领域是期货</div><div>编码规范：返回值使用result</div><div>超时、被打断的重要设计</div><div><br/></div><div>级联、点调</div><div>Fluent API</div><div><br/></div><div>示例代码中，增加，打印当前线程名称</div><div><br/></div><div>斐波那契数列</div><div>    递归</div><div>    使用数组，优化代码</div><div>尾递归</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 斐波那契数列</div><div>*/</div><div>public class FibDemo {</div><div>    public static void main(String[] args) {</div><div>        StopWatch sw = new StopWatch();</div><div>        sw.start(&quot;fib1&quot;);</div><div>        System.out.println(fib1(36));</div><div>        sw.stop();</div><div>        sw.start(&quot;fib2&quot;);</div><div>        System.out.println(fib2(36));</div><div>        sw.stop();</div><div>        System.out.println(sw.prettyPrint());</div><div>    }</div><div>    public static long fib1(int level) {</div><div>        long[] items = new long[level + 1];</div><div>        items[0] = 1;</div><div>        items[1] = 1;</div><div>        for (int i = 2; i &lt;= level; i++) {</div><div>            items[i] = items[i - 1] + items[i - 2];</div><div>        }</div><div>        return items[level];</div><div>    }</div><div>    public static long fib2(int level) {</div><div>        if (level &lt; 2) {</div><div>            return 1;</div><div>        }</div><div>        return fib2(level - 1) + fib2(level - 2);</div><div>    }</div><div>    /**</div><div>     * 24157817</div><div>     * 24157817</div><div>     * StopWatch '': running time = 90073800 ns</div><div>     * ---------------------------------------------</div><div>     * ns         %     Task name</div><div>     * ---------------------------------------------</div><div>     * 000272800  000%  fib1</div><div>     * 089801000  100%  fib2</div><div>     *</div><div>     * Process finished with exit code 0</div><div>     */</div><div>}</div></div><div><br/></div><div>JDK集合类源码</div><div>站在【如果让你设计，如何设计】的角度，去学习源码！</div><div><br/></div><div><br/></div><hr/><div>02:01:15</div><hr/><div>第8课课件</div><div><br/></div><div>1.常用线程安全类型</div><div>原生类型（基本数据类型）byte/short/int/long/float/double/boolean/char</div><div>数组类型</div><div>对象引用类型</div><div><br/></div><div>线性数据结构都源于Collection接口，并且拥有迭代器</div><div><img src="class08_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="class08_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div></div><div>1.1 ArrayList</div><div>基于数组，便于按index访问</div><div>超过数组需要扩容，扩容成本较高</div><div>用途：大部分情况下操作一组数据都可以用</div><div>原理：使用数组模拟列表，默认大小10，扩容*1.5</div><div>使用transient原因：</div><ol><li><div>重写了JDK自带序列化方法readObject、writeObject，把数组有值的遍历一遍序列化。</div></li><li><div>数组刚扩容，如果序列化对象数组，里面包含空的值。</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* The array buffer into which the elements of the ArrayList are stored.</div><div>* The capacity of the ArrayList is the length of this array buffer. Any</div><div>* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div>* will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div>*/</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">transient</span> Object[] elementData; // non-private to simplify nested class access</div><div><br/></div><div>/**</div><div>* The size of the ArrayList (the number of elements it contains).</div><div>*</div><div>* @serial</div><div>*/</div><div>private int size;</div><div><br/></div><div>private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException</div><div>private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException</div></div><div>安全问题：</div><ol><li><div>写冲突</div></li><ol><li><div>两个线程写，相互操作冲突</div></li></ol><li><div>读写冲突</div></li><ol><li><div>读的过程中，数据个数变了，拿到非预期数据或报错ConcurrentModificationException</div></li><li><div>删除数据时，倒着删除</div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>The iterators returned by this class's iterator and listIterator methods are <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">fail-fast</span>: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</div><div>此类的迭代器和listIterator方法返回的迭代器是快速失败的：如果在创建迭代器之后的任何时间以任何方式对列表进行结构修改，除非通过迭代器自己的remove或add方法，否则迭代器将抛出ConcurrentModificationException。 因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间冒着任意，不确定的行为的风险。</div></div><div><br/></div><div>1.2 LinkedList</div><div>使用链表实现，无需扩容</div><div>用途：不知道容量，插入变动多的场景</div><div>使用双向指针将所有节点连接起来</div><div>安全问题：与ArrayList一致</div><div>写冲突</div><div>读写冲突</div><div><img src="class08_files/Image [2].png" type="image/png" data-filename="Image.png"/><img src="class08_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>线程安全是写冲突和读写冲突导致的，最简单解决办法：读写都加锁</div><ol><li><div>ArrayList所有方法都加上synchronized，Vector就是这么实现的</div></li><li><div>Collections.synchronizedList(List&lt;T&gt; list)，强制将List的操作加上同步</div></li><li><div>Arrays.asList()，不允许添加删除，，但是可以set替换元素</div></li><li><div>Collections.unmodifiableList(List&lt;? extends T&gt; list)，不允许修改内容，add/remove/set都不允许</div></li></ol><div>get/add各自是原子操作，多个线程同时操作时，不能保证原子操作组合后还是原子操作。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static &lt;T&gt; List&lt;T&gt; <b>synchronizedList</b>(List&lt;T&gt; list)</div><div>Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list.</div><div>It is imperative that the user manually synchronize on the returned list when iterating over it:</div><div>  List list = Collections.synchronizedList(new ArrayList());</div><div>      ...</div><div>  synchronized (list) {</div><div>      Iterator i = list.iterator(); // Must be in synchronized block</div><div>      while (i.hasNext())</div><div>          foo(i.next());</div><div>  }</div><div>Failure to follow this advice may result in non-deterministic behavior.</div><div>The returned list will be serializable if the specified list is serializable.</div></div><div><br/></div><div>1.3 CopyOnWriteArrayList</div><div><img src="class08_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>核心改进原理：</div><ol><li><div>写加锁，保证不会混乱</div></li><li><div>写在一个Copy副本（快照）上，而不是原始数据上（GC young区复制，old区用本区内的移动）</div></li></ol><div>优雅停机、滚动发布</div><div>插入元素时，在新副本操作，不影响旧引用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean add(E e) {</div><div>    final ReentrantLock lock = this.lock;</div><div>    lock.lock();</div><div>    try {</div><div>        Object[] elements = getArray();</div><div>        int len = elements.length;</div><div>        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div>        newElements[len] = e;</div><div>        setArray(newElements);</div><div>        return true;</div><div>    } finally {</div><div>        lock.unlock();</div><div>    }</div><div>}</div><div>public E remove(int index) {</div><div>    final ReentrantLock lock = this.lock;</div><div>    lock.lock();</div><div>    try {</div><div>        Object[] elements = getArray();</div><div>        int len = elements.length;</div><div>        E oldValue = get(elements, index);</div><div>        int numMoved = len - index - 1;</div><div>        if (numMoved == 0)</div><div>            setArray(Arrays.copyOf(elements, len - 1));</div><div>        else {</div><div>            Object[] newElements = new Object[len - 1];</div><div>            System.arraycopy(elements, 0, newElements, 0, index);</div><div>            System.arraycopy(elements, index + 1, newElements, index,</div><div>                             numMoved);</div><div>            setArray(newElements);</div><div>        }</div><div>        return oldValue;</div><div>    } finally {</div><div>        lock.unlock();</div><div>    }</div><div>}</div><div>// 直接读取即可，无需加锁</div><div>public E get(int index) {</div><div>    return get(getArray(), index);</div><div>}</div><div>private E get(Object[] a, int index) {</div><div>    return (E) a[index];</div><div>}</div></div><div>使用迭代器时，直接将当前数组对象做一个快照，此后的List元素变动，跟这次迭代没关系。</div><div><img src="class08_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>淘宝商品item的快照，商品价格会变，每次下单都会生成一个当时商品信息的快照。如果发生任何纠纷，一定按照当时快照信息追溯。</div><div><br/></div><div>1.4 HashMap</div><div>空间换时间，哈希冲突不大的情况下查找数据性能很高（前提：数据均匀、稀疏）</div><div>用途：存放指定key的对象，缓存对象</div><div>原理：使用hash原理，存储key-value数据，初始容量16，扩容*2，负载因子0.75</div><div>JDK8以后，在链表长度到8&amp;数组长度到64时，使用红黑树。</div><div><br/></div><div>安全问题：</div><ol><li><div>写冲突</div></li><li><div>读写问题，可能会死循环</div></li><li><div>keys()无序问题</div></li></ol><div><br/></div><div>HashMap可能退化成单链表，查找性能比单链表还低，因为有hash操作的开销。</div><div><br/></div><div>从低版本升级到jdk8，有坑：</div><ol><li><div>如果从链表转换为红黑树后，keys()无序；要么不依赖这个顺序，要么查询keySet后代码中排序；要么改成LinkedHashMap；</div></li></ol><div><br/></div><div>1.5 LinkedHashMap</div><div>继承自HashMap，对Entry集合中添加了一个双向链表</div><div>用途：保证有序，特别是Java8 Stream操作的toMap时使用</div><div>原理：同LinkedList，包括插入顺序和访问顺序</div><div><br/></div><div>安全问题：同HashMap</div><div><br/></div><div>1.6 CouncurrentHashMap</div><div>java7使用分段锁</div><div>默认16个Segment，降低锁粒度。</div><div>Segment[[ 分库</div><div>HashEntry[] 分表</div><div><br/></div><div>jdk8借助于红黑树，CAS</div><div>使用Map存缓存，先get判断为空时put，这个操作不是原子的。</div><div>使用putIfAbsent方法</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class SyncListDemo {</div><div>    public static void main(String[] args) {</div><div>        List&lt;Integer&gt; list0 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8);</div><div>        // 可以修改内容，不能add/remove，否则抛异常java.lang.UnsupportedOperationException</div><div>        list0.set(8, 9);</div><div>//        list0.add(1);</div><div>//        list0.remove(1);</div><div><br/></div><div>        List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</div><div>        list1.addAll(list0);</div><div><br/></div><div>        List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</div><div>        System.out.println(Arrays.toString(list2.toArray()));</div><div>        Collections.shuffle(list2);</div><div>        System.out.println(Arrays.toString(list2.toArray()));</div><div><br/></div><div>        // 不再修改</div><div>        List&lt;Integer&gt; list3 = Collections.unmodifiableList(list2);</div><div>        // class java.util.Collections$UnmodifiableRandomAccessList</div><div>        System.out.println(list3.getClass());</div><div><br/></div><div>//        list3.set(8, 10);</div><div>        // Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</div><div>//        System.out.println(Arrays.toString(list3.toArray()));</div><div><br/></div><div>//        list3.add(11);</div><div>        // Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</div><div>//        System.out.println(Arrays.toString(list3.toArray()));</div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class LinkedHashMapDemo {</div><div>    public static void main(String[] args) {</div><div>        System.out.println(&quot;test HashMap&quot;);</div><div>        Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</div><div>        hashMap.put(&quot;name1&quot;, &quot;josan1&quot;);</div><div>        hashMap.put(&quot;name2&quot;, &quot;josan2&quot;);</div><div>        hashMap.put(&quot;name3&quot;, &quot;josan3&quot;);</div><div>        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</div><div>        while (iterator.hasNext()) {</div><div>            Map.Entry&lt;String, String&gt; next = iterator.next();</div><div>            System.out.println(next.getKey() + &quot; -&gt; &quot; + next.getValue());</div><div>        }</div><div>        System.out.println(&quot;test LinkedHashMap&quot;);</div><div>        LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</div><div>        linkedHashMap.put(&quot;name1&quot;, &quot;josan1&quot;);</div><div>        linkedHashMap.put(&quot;name2&quot;, &quot;josan2&quot;);</div><div>        linkedHashMap.put(&quot;name3&quot;, &quot;josan3&quot;);</div><div>        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = linkedHashMap.entrySet().iterator();</div><div>        while (iter.hasNext()) {</div><div>            Map.Entry&lt;String, String&gt; next = iter.next();</div><div>            System.out.println(next.getKey() + &quot; -&gt; &quot; + next.getValue());</div><div>        }</div><div>        /**</div><div>         * test HashMap</div><div>         * name3 -&gt; josan3</div><div>         * name2 -&gt; josan2</div><div>         * name1 -&gt; josan1</div><div>         * test LinkedHashMap</div><div>         * name1 -&gt; josan1</div><div>         * name2 -&gt; josan2</div><div>         * name3 -&gt; josan3</div><div>         */</div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class TreeMapDemo {</div><div>    public static void main(String[] args) {</div><div>        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(Comparator.reverseOrder());</div><div>        treeMap.put(3, &quot;val&quot;);</div><div>        treeMap.put(2, &quot;val&quot;);</div><div>        treeMap.put(5, &quot;val&quot;);</div><div>        treeMap.put(1, &quot;val&quot;);</div><div>        treeMap.put(4, &quot;val&quot;);</div><div>        // {5=val, 4=val, 3=val, 2=val, 1=val}</div><div>        System.out.println(treeMap);</div><div><br/></div><div>        TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(Comparator.naturalOrder());</div><div>        map.putAll(treeMap);</div><div>        // {1=val, 2=val, 3=val, 4=val, 5=val}</div><div>        System.out.println(map);</div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class ConcurrentHashMapDemo {</div><div>    public static void main(String[] args) {</div><div>        ConcurrentHashMap&lt;String, AtomicInteger&gt; cache = new ConcurrentHashMap&lt;&gt;();</div><div>        CountDownLatch endLatch = new CountDownLatch(2);</div><div>        Runnable task = () -&gt; {</div><div>            AtomicInteger oldValue;</div><div>            for (int i = 0; i &lt; 100; i++) {</div><div>                oldValue = cache.get(&quot;a&quot;);</div><div>                if (oldValue == null) {</div><div>                    AtomicInteger newValue = new AtomicInteger(0);</div><div>                    oldValue = cache.putIfAbsent(&quot;a&quot;, newValue);</div><div>                    if (oldValue == null) {</div><div>                        oldValue = newValue;</div><div>                    }</div><div>                }</div><div>                oldValue.incrementAndGet();</div><div>            }</div><div>            endLatch.countDown();</div><div>        };</div><div>        new Thread(task).start();</div><div>        new Thread(task).start();</div><div>        try {</div><div>            endLatch.await();</div><div>        } catch (InterruptedException e) {</div><div>            e.printStackTrace();</div><div>        }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span><span>    </span><span>    </span><span>   // </span></span>{a=200}</div><div>        System.out.println(cache);</div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 只有CopyOnWriteArrayList才不会报错</div><div>* 虽然Vector单个方法加synchronized同步关键字了，但是读写操作不是原子操作，所以也会报错</div><div>*/</div><div>public class CopyOnWriteArrayListDemo {</div><div>    public static void main(String[] args) {</div><div>//        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div>//        List&lt;Integer&gt; list = new Vector&lt;&gt;();</div><div>//        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</div><div>        List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();</div><div>        initList(list);</div><div>        new Thread(new ReadTask(list)).start();</div><div>        new Thread(new RemoveTask(list)).start();</div><div>    }</div><div>    private static void initList(List&lt;Integer&gt; list) {</div><div>        for (int i = 0; i &lt; 10_000; i++) {</div><div>            list.add(i);</div><div>        }</div><div>    }</div><div>    static class ReadTask implements Runnable {</div><div>        private List&lt;Integer&gt; list;</div><div>        public ReadTask(List&lt;Integer&gt; list) {</div><div>            this.list = list;</div><div>        }</div><div>        @Override</div><div>        public void run() {</div><div>            for (Integer i : list) {</div><div><br/></div><div><br/></div><div>            }</div><div>        }</div><div>    }</div><div>    static class RemoveTask implements Runnable {</div><div>        private List&lt;Integer&gt; list;</div><div>        public RemoveTask(List&lt;Integer&gt; list) {</div><div>            this.list = list;</div><div>        }</div><div>        @Override</div><div>        public void run() {</div><div>            for (int i = 0; i &lt; list.size(); i++) {</div><div>                list.remove(i);</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>使用容器类90%都没有超过初始值。</div><div>排序数量超过7个，快排，低于7个冒泡。</div><div>规模小、规模大、规模超大时，处理方式不同。</div><div><br/></div><hr/><div><br/></div><div>2.并发编程相关内容</div><div><br/></div><div>2.1 ThreadLocal 线程安全操作利器</div><div><br/></div><ul><li><div>线程本地变量</div></li><li><div>场景：每个线程一个副本</div></li><li><div>不改方法签名，静默传参</div></li><li><div>及时进行清理（防止内存泄漏，最关键的）</div></li></ul><div><br/></div><div>可以使用HashMap存储需要传递的参数，感觉太low，所以创造一个Context，显示或隐式的使用HashMap。</div><div>HashMap与对象的表达能力是相同的。</div><div>可以看做是Context模式，减少隐式传递参数</div><div><br/></div><div>2.2 并行Stream 四两拨千斤</div><div><br/></div><div>使用parallel()会使用线程异步执行</div><div>多线程执行，只需要加个parallel即可。</div><div>把业务和多线程通过parallel关键字，拆分开了。</div><div><br/></div><div>2.3 伪并发问题</div><div>与高并发冲突问题类似的场景，如浏览器端，表单的重复提交问题</div><div>解决：</div><ol><li><div>客户端控制，点击后按钮不可用，跳转到其他页</div></li><li><div>服务端控制，表单生成编号，提交时判断重复</div></li><li><div>站在客户的角度考虑，拆分步骤，及时通知用户。</div></li></ol><div><br/></div><div>2.4 分布式下的锁和计数器</div><div>前面讨论的都是在一个JVM中操作。</div><div>分布式环境下，多个机器操作，超出了线程的协作机制，一定是并行的</div><div>见分布式缓存详解</div><div><br/></div><hr/><div><br/></div><div>3. 并发编程经验总结</div><div><br/></div><div>3.1 加锁需要考虑的问题</div><ol><li><div>粒度</div></li><li><div>性能（关键），性能和一致性的平衡</div></li><li><div>重入</div></li><li><div>公平</div></li><li><div>自旋锁（spinlock），并发资源还可以的情况，如果CPU比较高负荷，越自旋越糟糕</div></li><li><div>脱离业务场景谈性能都是耍流氓</div></li><ol><li><div>业务系统，性能一般在SQL</div></li><li><div>中间件，性能一般在IO</div></li></ol></ol><div><br/></div><div>3.2 线程间协作和通信</div><div><br/></div><div>线程间共享</div><ul><li><div>static/示例变量（堆内存）</div></li><li><div>Lock</div></li><li><div>synchronized</div></li></ul><div>线程间协作</div><ul><li><div>Thread#join()</div></li><li><div>Object#wait/notify/notifyAll</div></li><li><div>Future/Callable</div></li><li><div>CountDownLatch</div></li><li><div>CyclicBarrier</div></li></ul><div><br/></div><div>不同进程间通信方式：</div><div>操作系统的信号量</div><div>kill -9 pid</div><div>管道 |，可以看做把某种流传递下去</div><div>共享内存</div><div>文件</div><div>剪切</div><div>socket</div><div>自定义协议，写到注册表里</div><div>数据库</div><div>MQ，redis</div><div><br/></div><div>kill -3 pid</div><div>在pid进程自己位置jstack打印</div><div><br/></div><div>数学中的同构，如果只是把名词换掉，性质一致。</div><div>找到相似性，举一反三。</div><div><br/></div></div></span>
</div></body></html> 